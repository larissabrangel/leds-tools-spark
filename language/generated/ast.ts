/******************************************************************************
 * This file was generated by langium-cli 3.0.3.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const SPARKTerminals = {
    WS: /\s+/,
    ID: /[_a-zA-Z][\w_]*/,
    INT: /[0-9]+/,
    STRING: /"[^"]*"|'[^']*'/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AbstractElement = EnumX | Module;

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export type DATATYPE = 'boolean' | 'cnpj' | 'cpf' | 'currency' | 'date' | 'datetime' | 'decimal' | 'email' | 'file' | 'integer' | 'mobilePhoneNumber' | 'phoneNumber' | 'string' | 'uuid' | 'void' | 'zipcode';

export function isDATATYPE(item: unknown): item is DATATYPE {
    return item === 'string' || item === 'integer' || item === 'decimal' || item === 'datetime' || item === 'date' || item === 'boolean' || item === 'uuid' || item === 'email' || item === 'cpf' || item === 'cnpj' || item === 'zipcode' || item === 'currency' || item === 'mobilePhoneNumber' || item === 'phoneNumber' || item === 'file' || item === 'void';
}

export type Entity = ImportedEntity | LocalEntity;

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export type FEATURE_TYPE = 'authentication';

export function isFEATURE_TYPE(item: unknown): item is FEATURE_TYPE {
    return item === 'authentication';
}

export type LANGUAGETYPE = 'csharp-clean-architecture' | 'csharp-minimal-api' | 'java' | 'python';

export function isLANGUAGETYPE(item: unknown): item is LANGUAGETYPE {
    return item === 'python' || item === 'java' || item === 'csharp-minimal-api' || item === 'csharp-clean-architecture';
}

export type QualifiedName = string;

export function isQualifiedName(item: unknown): item is QualifiedName {
    return typeof item === 'string';
}

export type QualifiedNameWithWildcard = string;

export function isQualifiedNameWithWildcard(item: unknown): item is QualifiedNameWithWildcard {
    return typeof item === 'string';
}

export type Relation = ManyToMany | ManyToOne | OneToMany | OneToOne;

export const Relation = 'Relation';

export function isRelation(item: unknown): item is Relation {
    return reflection.isInstance(item, Relation);
}

export type UseCaseElements = Actor | UseCase;

export const UseCaseElements = 'UseCaseElements';

export function isUseCaseElements(item: unknown): item is UseCaseElements {
    return reflection.isInstance(item, UseCaseElements);
}

export interface Actor extends AstNode {
    readonly $container: UseCasesModel;
    readonly $type: 'Actor';
    comment?: string;
    fullName?: string;
    id: QualifiedName;
    superType?: Reference<Actor>;
}

export const Actor = 'Actor';

export function isActor(item: unknown): item is Actor {
    return reflection.isInstance(item, Actor);
}

export interface Attribute extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'Attribute';
    blank: boolean;
    comment?: string;
    fullName?: string;
    max?: number;
    min?: number;
    name: string;
    type: DATATYPE;
    unique: boolean;
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface AttributeEnum extends AstNode {
    readonly $container: EnumX;
    readonly $type: 'AttributeEnum';
    comment?: string;
    fullName?: string;
    name: string;
}

export const AttributeEnum = 'AttributeEnum';

export function isAttributeEnum(item: unknown): item is AttributeEnum {
    return reflection.isInstance(item, AttributeEnum);
}

export interface Configuration extends AstNode {
    readonly $container: Model;
    readonly $type: 'Configuration';
    database_name?: string;
    description?: string;
    entity?: Reference<Entity>;
    feature?: FEATURE_TYPE;
    language?: LANGUAGETYPE;
    name?: string;
    package_path?: LANGUAGETYPE;
}

export const Configuration = 'Configuration';

export function isConfiguration(item: unknown): item is Configuration {
    return reflection.isInstance(item, Configuration);
}

export interface Element extends AstNode {
    readonly $container: Parameter;
    readonly $type: 'Element';
    comment?: string;
    name: string;
    type: DATATYPE;
}

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export interface EnumEntityAtribute extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'EnumEntityAtribute';
    comment?: string;
    name: string;
    type: Reference<EnumX>;
}

export const EnumEntityAtribute = 'EnumEntityAtribute';

export function isEnumEntityAtribute(item: unknown): item is EnumEntityAtribute {
    return reflection.isInstance(item, EnumEntityAtribute);
}

export interface EnumX extends AstNode {
    readonly $container: Model | Module;
    readonly $type: 'EnumX';
    attributes: Array<AttributeEnum>;
    comment?: string;
    name: string;
}

export const EnumX = 'EnumX';

export function isEnumX(item: unknown): item is EnumX {
    return reflection.isInstance(item, EnumX);
}

export interface Event extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'Event';
    action?: string;
    depends: Array<Reference<Event>>;
    description?: string;
    id: string;
    name_fragment?: string;
}

export const Event = 'Event';

export function isEvent(item: unknown): item is Event {
    return reflection.isInstance(item, Event);
}

export interface FunctionEntity extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'FunctionEntity';
    comment?: string;
    name: string;
    paramters: Array<Parameter>;
    response: DATATYPE;
}

export const FunctionEntity = 'FunctionEntity';

export function isFunctionEntity(item: unknown): item is FunctionEntity {
    return reflection.isInstance(item, FunctionEntity);
}

export interface ImportedEntity extends AstNode {
    readonly $container: ModuleImport;
    readonly $type: 'ImportedEntity';
    name: string;
}

export const ImportedEntity = 'ImportedEntity';

export function isImportedEntity(item: unknown): item is ImportedEntity {
    return reflection.isInstance(item, ImportedEntity);
}

export interface LocalEntity extends AstNode {
    readonly $container: Module;
    readonly $type: 'LocalEntity';
    attributes: Array<Attribute>;
    comment?: string;
    enumentityatributes: Array<EnumEntityAtribute>;
    functions: Array<FunctionEntity>;
    is_abstract: boolean;
    name: string;
    relations: Array<Relation>;
    superType?: Reference<Entity>;
}

export const LocalEntity = 'LocalEntity';

export function isLocalEntity(item: unknown): item is LocalEntity {
    return reflection.isInstance(item, LocalEntity);
}

export interface ManyToMany extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'ManyToMany';
    by?: Reference<LocalEntity>;
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}

export const ManyToMany = 'ManyToMany';

export function isManyToMany(item: unknown): item is ManyToMany {
    return reflection.isInstance(item, ManyToMany);
}

export interface ManyToOne extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'ManyToOne';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}

export const ManyToOne = 'ManyToOne';

export function isManyToOne(item: unknown): item is ManyToOne {
    return reflection.isInstance(item, ManyToOne);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    abstractElements: Array<AbstractElement | ModuleImport | UseCasesModel>;
    configuration?: Configuration;
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Module extends AstNode {
    readonly $container: Model | Module;
    readonly $type: 'Module';
    comment?: string;
    elements: Array<AbstractElement | LocalEntity>;
    name: QualifiedName;
}

export const Module = 'Module';

export function isModule(item: unknown): item is Module {
    return reflection.isInstance(item, Module);
}

export interface ModuleImport extends AstNode {
    readonly $container: Model;
    readonly $type: 'ModuleImport';
    entities: Array<ImportedEntity>;
    library: string;
    name: string;
    package_path: string;
}

export const ModuleImport = 'ModuleImport';

export function isModuleImport(item: unknown): item is ModuleImport {
    return reflection.isInstance(item, ModuleImport);
}

export interface OneToMany extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'OneToMany';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}

export const OneToMany = 'OneToMany';

export function isOneToMany(item: unknown): item is OneToMany {
    return reflection.isInstance(item, OneToMany);
}

export interface OneToOne extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'OneToOne';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}

export const OneToOne = 'OneToOne';

export function isOneToOne(item: unknown): item is OneToOne {
    return reflection.isInstance(item, OneToOne);
}

export interface Parameter extends AstNode {
    readonly $container: FunctionEntity;
    readonly $type: 'Parameter';
    comment?: string;
    element: Array<Element> | Element;
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface UseCase extends AstNode {
    readonly $container: UseCasesModel;
    readonly $type: 'UseCase';
    actors: Array<Reference<Actor>>;
    comment?: string;
    description?: string;
    events: Array<Event>;
    id: QualifiedName;
    name_fragment: string;
    superType?: Reference<UseCase>;
}

export const UseCase = 'UseCase';

export function isUseCase(item: unknown): item is UseCase {
    return reflection.isInstance(item, UseCase);
}

export interface UseCasesModel extends AstNode {
    readonly $container: Model;
    readonly $type: 'UseCasesModel';
    comment?: string;
    elements: Array<UseCaseElements>;
    id: QualifiedName;
}

export const UseCasesModel = 'UseCasesModel';

export function isUseCasesModel(item: unknown): item is UseCasesModel {
    return reflection.isInstance(item, UseCasesModel);
}

export type SPARKAstType = {
    AbstractElement: AbstractElement
    Actor: Actor
    Attribute: Attribute
    AttributeEnum: AttributeEnum
    Configuration: Configuration
    Element: Element
    Entity: Entity
    EnumEntityAtribute: EnumEntityAtribute
    EnumX: EnumX
    Event: Event
    FunctionEntity: FunctionEntity
    ImportedEntity: ImportedEntity
    LocalEntity: LocalEntity
    ManyToMany: ManyToMany
    ManyToOne: ManyToOne
    Model: Model
    Module: Module
    ModuleImport: ModuleImport
    OneToMany: OneToMany
    OneToOne: OneToOne
    Parameter: Parameter
    Relation: Relation
    UseCase: UseCase
    UseCaseElements: UseCaseElements
    UseCasesModel: UseCasesModel
}

export class SPARKAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractElement', 'Actor', 'Attribute', 'AttributeEnum', 'Configuration', 'Element', 'Entity', 'EnumEntityAtribute', 'EnumX', 'Event', 'FunctionEntity', 'ImportedEntity', 'LocalEntity', 'ManyToMany', 'ManyToOne', 'Model', 'Module', 'ModuleImport', 'OneToMany', 'OneToOne', 'Parameter', 'Relation', 'UseCase', 'UseCaseElements', 'UseCasesModel'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Actor:
            case UseCase: {
                return this.isSubtype(UseCaseElements, supertype);
            }
            case EnumX:
            case Module: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case ImportedEntity:
            case LocalEntity: {
                return this.isSubtype(Entity, supertype);
            }
            case ManyToMany:
            case ManyToOne:
            case OneToMany:
            case OneToOne: {
                return this.isSubtype(Relation, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Actor:superType':
            case 'UseCase:actors': {
                return Actor;
            }
            case 'Configuration:entity':
            case 'LocalEntity:superType':
            case 'ManyToMany:type':
            case 'ManyToOne:type':
            case 'OneToMany:type':
            case 'OneToOne:type': {
                return Entity;
            }
            case 'EnumEntityAtribute:type': {
                return EnumX;
            }
            case 'Event:depends': {
                return Event;
            }
            case 'ManyToMany:by': {
                return LocalEntity;
            }
            case 'UseCase:superType': {
                return UseCase;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Actor': {
                return {
                    name: 'Actor',
                    properties: [
                        { name: 'comment' },
                        { name: 'fullName' },
                        { name: 'id' },
                        { name: 'superType' }
                    ]
                };
            }
            case 'Attribute': {
                return {
                    name: 'Attribute',
                    properties: [
                        { name: 'blank', defaultValue: false },
                        { name: 'comment' },
                        { name: 'fullName' },
                        { name: 'max' },
                        { name: 'min' },
                        { name: 'name' },
                        { name: 'type' },
                        { name: 'unique', defaultValue: false }
                    ]
                };
            }
            case 'AttributeEnum': {
                return {
                    name: 'AttributeEnum',
                    properties: [
                        { name: 'comment' },
                        { name: 'fullName' },
                        { name: 'name' }
                    ]
                };
            }
            case 'Configuration': {
                return {
                    name: 'Configuration',
                    properties: [
                        { name: 'database_name' },
                        { name: 'description' },
                        { name: 'entity' },
                        { name: 'feature' },
                        { name: 'language' },
                        { name: 'name' },
                        { name: 'package_path' }
                    ]
                };
            }
            case 'Element': {
                return {
                    name: 'Element',
                    properties: [
                        { name: 'comment' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case 'EnumEntityAtribute': {
                return {
                    name: 'EnumEntityAtribute',
                    properties: [
                        { name: 'comment' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case 'EnumX': {
                return {
                    name: 'EnumX',
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'comment' },
                        { name: 'name' }
                    ]
                };
            }
            case 'Event': {
                return {
                    name: 'Event',
                    properties: [
                        { name: 'action' },
                        { name: 'depends', defaultValue: [] },
                        { name: 'description' },
                        { name: 'id' },
                        { name: 'name_fragment' }
                    ]
                };
            }
            case 'FunctionEntity': {
                return {
                    name: 'FunctionEntity',
                    properties: [
                        { name: 'comment' },
                        { name: 'name' },
                        { name: 'paramters', defaultValue: [] },
                        { name: 'response' }
                    ]
                };
            }
            case 'ImportedEntity': {
                return {
                    name: 'ImportedEntity',
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case 'LocalEntity': {
                return {
                    name: 'LocalEntity',
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'comment' },
                        { name: 'enumentityatributes', defaultValue: [] },
                        { name: 'functions', defaultValue: [] },
                        { name: 'is_abstract', defaultValue: false },
                        { name: 'name' },
                        { name: 'relations', defaultValue: [] },
                        { name: 'superType' }
                    ]
                };
            }
            case 'ManyToMany': {
                return {
                    name: 'ManyToMany',
                    properties: [
                        { name: 'by' },
                        { name: 'comment' },
                        { name: 'fullName' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case 'ManyToOne': {
                return {
                    name: 'ManyToOne',
                    properties: [
                        { name: 'comment' },
                        { name: 'fullName' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    properties: [
                        { name: 'abstractElements', defaultValue: [] },
                        { name: 'configuration' }
                    ]
                };
            }
            case 'Module': {
                return {
                    name: 'Module',
                    properties: [
                        { name: 'comment' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case 'ModuleImport': {
                return {
                    name: 'ModuleImport',
                    properties: [
                        { name: 'entities', defaultValue: [] },
                        { name: 'library' },
                        { name: 'name' },
                        { name: 'package_path' }
                    ]
                };
            }
            case 'OneToMany': {
                return {
                    name: 'OneToMany',
                    properties: [
                        { name: 'comment' },
                        { name: 'fullName' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case 'OneToOne': {
                return {
                    name: 'OneToOne',
                    properties: [
                        { name: 'comment' },
                        { name: 'fullName' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case 'Parameter': {
                return {
                    name: 'Parameter',
                    properties: [
                        { name: 'comment' },
                        { name: 'element' }
                    ]
                };
            }
            case 'UseCase': {
                return {
                    name: 'UseCase',
                    properties: [
                        { name: 'actors', defaultValue: [] },
                        { name: 'comment' },
                        { name: 'description' },
                        { name: 'events', defaultValue: [] },
                        { name: 'id' },
                        { name: 'name_fragment' },
                        { name: 'superType' }
                    ]
                };
            }
            case 'UseCasesModel': {
                return {
                    name: 'UseCasesModel',
                    properties: [
                        { name: 'comment' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'id' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new SPARKAstReflection();
